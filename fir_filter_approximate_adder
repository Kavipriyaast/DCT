// Module: fir_filter
// Description: This module implements an 8-tap Finite Impulse Response (FIR) filter using
//              approximate adders for summing the products of inputs and coefficients.
//              The module is parameterized to handle different bit widths for the inputs
//              and coefficients.

module fir_filter #(parameter bit_width = 16) (clk, rst, x0, x1, x2, x3, x4, x5, x6, x7, coeff0, coeff1, coeff2, coeff3, coeff4, coeff5, coeff6, coeff7, y_out);
    input clk, rst;  // Clock and reset signals
    input signed [bit_width-1:0] x0, x1, x2, x3, x4, x5, x6, x7;  // Input samples
    input signed [bit_width-1:0] coeff0, coeff1, coeff2, coeff3, coeff4, coeff5, coeff6, coeff7;  // Filter coefficients
    output reg signed [bit_width-1:0] y_out;  // Filtered output

    wire signed [23:0] mult [0:7];  // 24-bit products of inputs and coefficients
    wire signed [23:0] sum1, sum2, sum3, sum4, final_sum;  // Intermediate and final sums
    wire carry1, carry2, carry3, carry4, carry_final;  // Carry signals for approximate adders

    // Calculate products of inputs and coefficients
    assign mult[0] = x0 * coeff0;
    assign mult[1] = x1 * coeff1;
    assign mult[2] = x2 * coeff2;
    assign mult[3] = x3 * coeff3;
    assign mult[4] = x4 * coeff4;
    assign mult[5] = x5 * coeff5;
    assign mult[6] = x6 * coeff6;
    assign mult[7] = x7 * coeff7;

    // Sum the products using approximate adders
    approximate_adder sum_stage1 (.A(mult[0]), .B(mult[1]), .carry_in(0), .sum(sum1), .carry_out(carry1));
    approximate_adder sum_stage2 (.A(mult[2]), .B(mult[3]), .carry_in(carry1), .sum(sum2), .carry_out(carry2));
    approximate_adder sum_stage3 (.A(mult[4]), .B(mult[5]), .carry_in(carry2), .sum(sum3), .carry_out(carry3));
    approximate_adder sum_stage4 (.A(mult[6]), .B(mult[7]), .carry_in(carry3), .sum(sum4), .carry_out(carry4));
    approximate_adder final_sum_stage (.A(sum1), .B(sum2), .carry_in(carry4), .sum(final_sum), .carry_out(carry_final));

    // Always block triggered on the rising edge of the clock or when reset is active
    always @(posedge clk or posedge rst) begin
        if (rst)
            y_out <= 0;  // If reset is active, initialize the output to 0
        else
            y_out <= final_sum[15:0];  // Output the lower 16 bits of the final sum
    end
endmodule
